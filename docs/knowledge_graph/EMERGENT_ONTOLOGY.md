# Emergent Domain Ontology System

## Overview

Rather than using a static, predefined domain ontology, this system **discovers semantic categories emergently from the data** and **evolves them over time** as new content arrives.

## Key Advantages Over Static Ontology

### 1. **Data-Driven Discovery**
- Categories emerge from actual patterns in the data
- No human bias in predetermining what categories should exist
- Discovers unexpected semantic groupings

### 2. **Continuous Evolution**
- Adapts as new episodes are added
- Learns from novel relationships
- Merges or splits categories based on evidence

### 3. **Incremental Learning**
- Doesn't require reprocessing all data when new content arrives
- Efficiently updates with streaming data
- Maintains history of ontology evolution

## How It Works

### Initial Discovery Phase
```python
# When starting fresh, discovers domain types from all existing relationships
system = EmergentOntologySystem()
domain_types = system.discover_domain_types(all_837_raw_relationships)

# Uses DBSCAN clustering on embeddings to find semantic groups
# No need to predefine number of clusters - emerges from data density
```

**Process:**
1. **Embed** all raw relationship types (837+) using OpenAI
2. **Cluster** using DBSCAN with cosine similarity
3. **Name** clusters using GPT based on members
4. **Infer** properties from patterns in cluster members
5. **Calculate** confidence based on cluster cohesion

### Evolution with New Episodes
```python
# As each new episode is processed
new_relationships = ["ADVOCATES_FOR", "HAS_DEEP_KNOWLEDGE_OF", "TRANSFORMS_WASTE_INTO"]
system.evolve_with_new_relationships(new_relationships)
```

**Evolution Algorithm:**
```
For each new relationship:
  1. Calculate embedding
  2. Find similarity to all existing domain types

  If similarity >= 0.7:
    → Assign to existing domain type
    → Update domain centroid incrementally

  Elif similarity >= 0.5:
    → Create subdomain (hierarchical structure)
    → Track parent relationship

  Else:
    → Create new domain type
    → May merge with others later
```

### Automatic Domain Mergers
```python
# System periodically checks if domains should merge
If similarity(domain_A, domain_B) >= 0.85:
  → Merge B into A
  → Recalculate centroid
  → Preserve history
```

## Example Evolution Scenario

### Episode 1-50 Processed
```
Discovered Domain Types:
- DOMAIN_MENTORS (15 members): TEACHES, GUIDES, COACHES, MENTORS...
- DOMAIN_CREATES (23 members): BUILDS, PRODUCES, MANUFACTURES...
- DOMAIN_ECOLOGICAL (18 members): SEQUESTERS, REGENERATES, CONSERVES...
```

### Episode 51 Arrives
New relationship: `CARBON_NEGATIVE_IMPACT_ON`

**System Decision:**
- Similarity to DOMAIN_ECOLOGICAL: 0.68 (moderate)
- Creates subdomain: DOMAIN_CARBON_IMPACT
- Links to parent: DOMAIN_ECOLOGICAL

### Episode 75 Arrives
New relationship: `DRAWS_DOWN_CARBON_FROM`

**System Decision:**
- Similarity to DOMAIN_CARBON_IMPACT: 0.82 (high)
- Assigns to DOMAIN_CARBON_IMPACT
- Updates centroid
- Domain grows stronger

### Episode 100 Review
System detects:
- DOMAIN_CARBON_IMPACT and DOMAIN_ECOLOGICAL similarity: 0.86
- **Merges** DOMAIN_CARBON_IMPACT back into DOMAIN_ECOLOGICAL
- Carbon relationships now form strong subcluster within ecological domain

## Properties Discovery

The system infers properties from patterns:

```python
# If cluster contains: FUNDS, INVESTS_IN, FINANCES, GRANTS
Properties inferred:
{
  "financial": True,
  "resource_transfer": True,
  "enables": True
}

# If cluster contains: CAUSES, LEADS_TO, RESULTS_IN
Properties inferred:
{
  "causal": True,
  "directional": True,
  "temporal": True
}
```

## Query Advantages

### Dynamic Query Mapping
```python
# Query: "Who funds environmental projects?"
# System:
1. Embeds "funds" → Finds DOMAIN_FINANCIAL (0.89 similarity)
2. Embeds "environmental" → Finds DOMAIN_ECOLOGICAL (0.91 similarity)
3. Searches intersection
```

### Novel Query Handling
```python
# Query: "blockchain carbon credits" (never seen before)
# System:
1. No direct domain match
2. Creates temporary query domain
3. Finds relationships with similar embeddings
4. Learns from user feedback to potentially create new domain
```

## Implementation Details

### Clustering Parameters (Tunable)
- `min_cluster_size`: 3 (minimum relationships to form domain)
- `similarity_threshold`: 0.7 (for assignment)
- `merge_threshold`: 0.85 (for combining domains)
- `novelty_threshold`: 0.5 (below = create new domain)

### Storage Format
```json
{
  "domain_types": {
    "DOMAIN_0": {
      "id": "DOMAIN_0",
      "name": "MENTORS",  // Generated by GPT from members
      "raw_members": ["TEACHES", "GUIDES", "COACHES", ...],
      "centroid_embedding": [0.12, -0.34, ...],  // 1536 dims
      "properties": {
        "knowledge_transfer": true,
        "implies_seniority": true
      },
      "confidence": 0.82,  // Cluster cohesion
      "frequency": 47,     // Usage count
      "evolution_history": [
        {
          "type": "merger",
          "merged_from": "DOMAIN_15",
          "timestamp": "2024-03-15T10:23:45"
        }
      ]
    }
  }
}
```

## Advantages for Long-term Growth

### 1. **No Schema Lock-in**
- Traditional: Fixed 150 domain types
- Emergent: Unlimited evolution as corpus grows

### 2. **Handles Domain Shift**
- If podcast topics shift over time, ontology adapts
- New themes automatically get their own domains
- Old unused domains naturally fade

### 3. **Cross-Domain Learning**
- Relationships between domains discovered through evolution
- Hierarchical structure emerges from data
- Semantic bridges form between communities

### 4. **Quality Improvement**
- Domains get more accurate with more examples
- Weak domains merge or dissolve
- Strong patterns reinforce over time

## Usage Examples

### Initial Discovery (Run Once)
```bash
python scripts/emergent_ontology.py --discover
# Processes all 837+ raw relationships
# Creates initial emergent ontology
```

### Evolution (Run for Each New Episode)
```bash
python scripts/emergent_ontology.py --evolve episode_173_extraction.json
# Incrementally updates ontology
# Handles novel relationships
```

### Generate Report
```bash
python scripts/emergent_ontology.py --report
# Shows current domains, frequencies, evolution history
```

## Comparison: Static vs Emergent

| Aspect | Static Ontology | Emergent Ontology |
|--------|----------------|-------------------|
| **Creation** | Human-designed 150 types | Data-discovered N types |
| **Flexibility** | Fixed categories | Dynamic categories |
| **New Relationships** | Force-fit to existing | Create new or evolve |
| **Maintenance** | Manual updates | Self-organizing |
| **Domain Shift** | Requires redesign | Automatic adaptation |
| **Unexpected Patterns** | Missed | Discovered |
| **Scaling** | Linear complexity | Sublinear (incremental) |

## Integration with Knowledge Graph

### Query Processing
```python
def process_query(natural_language_query):
    # 1. Embed query
    query_embedding = get_embedding(natural_language_query)

    # 2. Find relevant domains dynamically
    relevant_domains = []
    for domain in emergent_ontology.domain_types:
        similarity = cosine_similarity(query_embedding, domain.centroid)
        if similarity > threshold:
            relevant_domains.append(domain)

    # 3. Search within discovered domains
    return search_in_domains(relevant_domains)
```

### Feedback Loop
```python
# User indicates a result was relevant/irrelevant
def process_feedback(query, result, relevant: bool):
    if relevant:
        # Strengthen connection between query and result's domain
        domain = get_domain(result.relationship_type)
        domain.add_positive_example(query)
    else:
        # Might indicate need for new domain
        check_for_domain_split(query, result)
```

## Future Enhancements

### 1. **Hierarchical Emergence**
- Let multi-level hierarchy emerge from data
- Discover not just domains but meta-domains

### 2. **Temporal Domains**
- Track how domains evolve over time
- Identify trending vs stable relationships

### 3. **Cross-Episode Patterns**
- Discover domains that only appear across multiple episodes
- Find long-range semantic dependencies

### 4. **Active Learning**
- System suggests relationships to verify
- Asks for human input on ambiguous clusters

## Conclusion

The emergent ontology system transforms the knowledge graph from a **static taxonomy** into a **living, learning system** that:

1. **Discovers** its own semantic categories from data
2. **Evolves** continuously as new content arrives
3. **Adapts** to changing domains and topics
4. **Improves** through use and feedback
5. **Scales** efficiently with incremental updates

This approach is particularly powerful for the YonEarth podcast because:
- Topics and themes can evolve naturally over 172+ episodes
- New concepts and relationships don't break the system
- The ontology becomes a **knowledge discovery tool** itself
- It reveals the true semantic structure of the podcast content

Rather than imposing our assumptions about what categories should exist, we let the data tell us what semantic patterns actually exist.